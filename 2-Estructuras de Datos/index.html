<!doctype html>
<html lang="es">

	<head>
		<meta charset="utf-8">
		<title>Estructuras de Datos</title>
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
		<link rel="stylesheet" href="../assets/css/reveal.css">
		<link rel="stylesheet" href="../assets/css/theme/ufps.css" id="theme">
		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="../assets/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../assets/css/print/pdf.css' : '../assets/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Unidad 2</h3>
                    <p>Estructuras de Datos, Ejercicios</p>   
				</section>

        <section>
          <p>Una Estructura de Datos es un medio de <strong>almacenar</strong>
            y <strong>organizar</strong> datos.
          </p>
        </section>
                <section>
                	<ul>
                    <li>Arreglos</li>
                    <li>ArrayList</li>
                    <li>Pilas</li>
                    <li>Colas</li>
                    <li>TreeSet</li>
                    <li>TreeMap</li>
                    <li>Ejercicios Propuestos</li>
                  </ul>
                </section>

        <section>
          <h3>Arreglos</h3>
          <p>Colecciones de datos secuenciales para ser almacenadas y accedidas luego
            a traves de sus indices.</p>
          <p>
            La cantidad de elementos a almacenar es <strong>fija</strong>.
          </p>

        </section>

        <section>
          <img src="img/arreglo.jpg" alt="">
        </section>

				<section>
					<pre>
						<code data-trim contenteditable>

/*
Declaración de un arreglo
tipo_dato nombre [];

Asignación
nombre[]=new tipo_dato [tamaño];
*/

int datos[]=new int[10];
double numeros[]=new double[12];
char caracteres[]=new char[26];
						</code>
					</pre>
				</section>

         <section>
          <h3>Arrays: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>fill(array[], data)</td>
              <td>Asigna el valor <strong>data</strong> a cada una de las posiciones del <strong>array</strong></td>
            </tr>
            <tr>
              <td>sort(array[])</td>
              <td>Ordena el <strong>array</strong> de forma ascendente.</td>
            </tr>
            <tr>
              <td>binarySearch(array[], key)</td>
              <td>Busca el valor <strong>key</strong> dentro del <strong>array</strong>. Retorna el indice o el <i>punto de inserción</i> del elemento.</td>
            </tr>
          </table>
        </section>

        <section>
          <pre>
            <code data-trim contenteditable>
import java.util.Arrays;

int datos[]=new int[10];

/*fill*/
Arrays.fill(datos, 4);
System.out.println(Arrays.toString(datos));

/*Salida: [4, 4, 4, 4, 4, 4, 4, 4, 4, 4]*/

int j=0;
for(int i=10; i>0; i--, j++){
    datos[j]=i;
}

System.out.println(Arrays.toString(datos));

/*Salida: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]*/

/*sort*/
Arrays.sort(datos);
System.out.println(Arrays.toString(datos));

/*Salida: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]*/

            </code>
          </pre>
        </section>

        <section>
          <pre>
            <code data-trim contenteditable>
System.out.println(Arrays.toString(datos));

/*Salida: [7, 2, 16, 11, 5, 15, 9, 4, 23, 10]*/

Arrays.sort(datos);
System.out.println(Arrays.toString(datos));
/*Salida: [2, 4, 5, 7, 9, 10, 11, 15, 16, 23]*/
    
System.out.println(Arrays.binarySearch(datos, 4));
/*Salida: 1*/

System.out.println(Arrays.binarySearch(datos, 1));
/*Salida: -1*/

System.out.println(Arrays.binarySearch(datos, 23));
/*Salida: 9*/

System.out.println(Arrays.binarySearch(datos, 12));
/*Salida: -8*/

            </code>
          </pre>
        </section>

				<section>
					<p>También podemos declarar arreglos de varias dimensiones</p>
          <pre>
            <code data-trim contenteditable>
/*
Declaración de un arreglo multidimensional
tipo_dato nombre [] [];

Asignación
nombre[] []=new tipo_dato [tamañoN] [tamañoM];
*/

int datos[]=new int [5] [3];
    
datos[0] [1]=5;
System.out.println(datos[0] [1]);
            </code>
          </pre>
				</section>

        <section>
          <h3>ArrayList</h3>
          <p>Colecciones de datos secuenciales para ser almacenadas y accedidas luego
            a traves de sus indices.</p>
          <p>
            La cantidad de elementos a almacenar es <strong>variable</strong>.
          </p>
        </section>

        <section>
          <pre>
            <code data-trim contenteditable>
import java.util.ArrayList;

//Declaración de un ArrayList

ArrayList&lt;Integer&gt; datos=new ArrayList&lt;Integer&gt;();
ArrayList&lt;Double&gt; numeros=new ArrayList&lt;Double&gt;();
ArrayList&lt;Character&gt; caracteres=new ArrayList&lt;Character&gt;();
            </code>
          </pre>
        </section>

        <section>
          <h3>ArrayList: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>add(data)</td>
              <td>Añade el valor <strong>data</strong> al final del <strong>ArrayList</strong>.</td>
            </tr>
            <tr>
              <td>clear()</td>
              <td>Elimina todos los elementos del <strong>ArrayList</strong>.</td>
            </tr>
            <tr>
              <td>contains(data)</td>
              <td>Retorna un <i>boolean</i> que indica si <strong>data</strong> se encuentra en el <strong>ArrayList</strong>.</td>
            </tr>
          </table>
        </section>

        <section>
          <h3>ArrayList: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>get(index)</td>
              <td>Retorna el elemento que se encuentra en la posición <strong>index</strong> del <strong>ArrayList</strong>.</td>
            </tr>
            <tr>
              <td>indexOf(data)</td>
              <td>Retorna el indice en el que se encuentra <strong>data</strong> dentro del <strong>ArrayList</strong>.</td>
            </tr>
            <tr>
              <td>isEmpty()</td>
              <td>Retorna un <i>boolean</i> que indica si el <strong>ArrayList</strong> tiene elementos o no.</td>
            </tr>
          </table>
        </section>

        <section>
          <h3>ArrayList: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>remove(index)</td>
              <td>Elimina el elemento que se encuentra en la posición <strong>index</strong> del <strong>ArrayList</strong>.</td>
            </tr>
            <tr>
              <td>remove(data)</td>
              <td>Elimina el elemento <strong>data</strong> del <strong>ArrayList</strong>.</td>
            </tr>
            <tr>
              <td>size()</td>
              <td>Retorna el número de elementos del <strong>ArrayList</strong>.</td>
            </tr>
          </table>
        </section>
				
        <section>
          <h3>ArrayList: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>set(index, data)</td>
              <td>Remplaza el elemento que se encuentra en la posición <strong>index</strong> del <strong>ArrayList</strong> con <strong>data</strong>.</td>
            </tr>
          </table>
        </section>

        <section>
          <pre>
            <code data-trim contenteditable>
import java.util.ArrayList;

ArrayList&lt;Integer&gt; datos=new ArrayList&lt;Integer&gt;();
    
for(int j=10; j>0; j--){
  datos.add(j);
}
    
datos.set(5, 13);
    
for(int j=0; j&lt;10; j++){
  System.out.print(datos.get(j)+" - ");
}
System.out.println();

/*Salida: 10 - 9 - 8 - 7 - 6 - 13 - 4 - 3 - 2 - 1 - */
    
System.out.println(datos.indexOf(4));
/*Salida: 6*/

System.out.println(datos.indexOf(17));
/*Salida: -1*/

System.out.println(datos.size());
/*Salida: 10*/

            </code>
          </pre>
        </section>

        <section>
          <p>¿Fill, Sort, BinarySearch? ¡También es posible!</p>
          <pre>
            <code data-trim contenteditable>
import java.util.Collections;

Collections.sort(datos);
/*Salida: 1 - 2 - 3 - 4 - 6 - 7 - 8 - 9 - 10 - 13 - */


System.out.println(Collections.binarySearch(datos, 0));
System.out.println(Collections.binarySearch(datos, 3));
/*Salida: -1
           2
*/
    
/*
Fill reemplaza todos los valores del ArrayList con el dato especificado
*/
Collections.fill(datos, 6);

            </code>
          </pre>
        </section>

        <section>
          <h3>Pilas (Stack)</h3>
          <p>Son contenedores dinámicos que poseen un comportamiento <strong>LIFO</strong> (Last
            In First Out), y por lo tanto solo se pueden insertar y eliminar elementos
            del final de la estructura.</p>
        </section>

        <section>
          <img src="img/pilas.png" alt="">
          <img src="img/pilas2.png" alt="">
        </section>

        <section>
          <pre>
            <code data-trim contenteditable>
import java.util.Stack;

//Declaración de una Pila

Stack&lt;Integer&gt; pila=new Stack&lt;Integer&gt;();
Stack&lt;String&gt; nombres=new Stack&lt;String&gt;();
Stack&lt;Float&gt; numeros=new Stack&lt;Float&gt;();
            </code>
          </pre>
        </section>

        <section>
          <h3>Stack: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>empty()</td>
              <td>Retorna un <i>boolean</i> que indica si la <strong>pila</strong> se encuentra vacia.</td>
            </tr>
            <tr>
              <td>peek()</td>
              <td>Retorna el elemento del tope de la <strong>Pila</strong>.</td>
            </tr>
            <tr>
              <td>pop()</td>
              <td>Retorna y elimina el elemento del tope de la <strong>Pila</strong>.</td>
            </tr>
          </table>
        </section>

        <section>
          <h3>Stack: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>push(data)</td>
              <td>Inserta el elemento <strong>data</strong> en el tope de la  <strong>Pila</strong>.</td>
            </tr>
            <tr>
              <td>search(data)</td>
              <td>Retorna la posicion en la que se encuentra el elemento <strong>data</strong> contando desde el tope de la <strong>Pila</strong>.</td>
            </tr>
          </table>
        </section> 

        <section>
          <pre>
            <code data-trim contenteditable>

Stack&lt;Integer&gt; pila=new Stack&lt;Integer&gt;();

for(int i=0; i&lt;10; i++){
  pila.push(i);
}
    
System.out.println(pila.peek());
/*Salida: ¿? */

System.out.println(pila.pop());
/*Salida: ¿? */

System.out.println(pila.pop());
/*Salida: 8 */

System.out.println(pila.search(7));
/*Salida: ¿? */

System.out.println(pila.search(2));
/*Salida: 6 */
            </code>
          </pre>
        </section>

        <section>
          <h3>Colas (Queue)</h3>
          <p>Son contenedores dinámicos que poseen un comportamiento <strong>FIFO</strong> (First
            In First Out), y por lo tanto solo se pueden insertar elementos al final y eliminar elementos
            del principio de la estructura.</p>
        </section>

        <section>
          <img src="img/cola.gif" alt="">
        </section>

        <section>
          <pre>
            <code data-trim contenteditable>
import java.util.LinkedList;
import java.util.Queue;

//Declaración de una Cola

Queue&lt;Integer&gt; cola=new LinkedList&lt;Integer&gt;();
Queue&lt;String&gt; nombres=new LinkedList&lt;String&gt;();
Queue&lt;Float&gt; numeros=new LinkedList&lt;Float&gt;();
            </code>
          </pre>
        </section>

        <section>
          <h3>Queue: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>add(data)</td>
              <td>Inserta el elemento <strong>data</strong> al final de la <strong>Cola</strong>.</td>
            </tr>
            <tr>
              <td>peek()</td>
              <td>Retorna el elemento del inicio de la <strong>Cola</strong>.</td>
            </tr>
            <tr>
              <td>poll()</td>
              <td>Retorna y elimina el elemento del inicio de la <strong>Cola</strong>.</td>
            </tr>
          </table>
        </section>

        <section>
          <h3>Queue: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>isEmpty()</td>
              <td>Retorna un <i>boolean</i> que indica si la <strong>Cola</strong> se encuentra vacia.</td>
            </tr>
            <tr>
              <td>size()</td>
              <td>Retorna la cantidad de elementos que se encuentran en la <strong>Cola</strong>.</td>
            </tr>
          </table>
        </section> 

        <section>
          <pre>
            <code data-trim contenteditable>

Queue&lt;Integer&gt; cola = new LinkedList&lt;Integer&gt;();
    
System.out.println(cola.size());
/*Salida: 0*/
    
for(int i=0; i&lt;10; i++){
  cola.add(i);
}
    
System.out.println(cola.peek());
/*Salida: 0*/

System.out.println(cola.poll());
/*Salida: ¿?*/

System.out.println(cola.poll());
/*Salida: ¿?*/
            </code>
          </pre>
        </section>

        <section>
          <h3>TreeSet</h3>
          <p>Un Arbol Binario de Busqueda Balanceado es un manera de <strong>organizar</strong> datos. Nos permite realizar operaciones de búsqueda, inserción y borrados de manera eficiente.</p>
        </section>

        <section>
          <img src="img/bst.png" alt="">
        </section>

        <section>
          <pre>
            <code data-trim contenteditable>
import java.util.TreeSet;

//Declaración de un TreeSet

TreeSet&lt;Integer&gt; tree=new TreeSet&lt;Integer&gt;();
TreeSet&lt;String&gt; nombres=new TreeSet&lt;String&gt;();
TreeSet&lt;Character&gt; numeros=new TreeSet&lt;Character&gt;();
            </code>
          </pre>
        </section>

        <section>
          <h3>TreeSet: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>add(data)</td>
              <td>Inserta el elemento <strong>data</strong> en el <strong>TreeSet</strong>.</td>
            </tr>
            <tr>
              <td>clear()</td>
              <td>Elimina todos los elementos del <strong>TreeSet</strong>.</td>
            </tr>
            <tr>
              <td>contains(data)</td>
              <td>Retorna un <i>boolean</i> que indica si el elemento <strong>data</strong> se encuentra en el <strong>TreeSet</strong>.</td>
            </tr>
          </table>
        </section>

        <section>
          <h3>TreeSet: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>first()</td>
              <td>Retorna el elemento más pequeño del <strong>TreeSet</strong>.</td>
            </tr>
            <tr>
              <td>isEmpty()</td>
              <td>Retorna un <i>boolean</i> que indica si el <strong>TreeSet</strong> se encuentra vacio.</td>
            </tr>
             <tr>
              <td>last()</td>
              <td>Retorna el elemento más grande del <strong>TreeSet</strong>.</td>
            </tr>
          </table>
        </section> 

        <section>
          <h3>TreeSet: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>pollFirst()</td>
              <td>Retorna y elimina el elemento más pequeño del <strong>TreeSet</strong>.</td>
            </tr>
            <tr>
              <td>pollLast()</td>
              <td>Retorna y elimina el elemento más grande del <strong>TreeSet</strong>.</td>
            </tr>
            <tr>
              <td>remove(data)</td>
              <td>Elimina el elemento <strong>data</strong> del <strong>TreeSet</strong>.</td>
            </tr>
          </table>
        </section>

        <section>
          <h3>TreeSet: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>size()</td>
              <td>Retorna el número de elementos del <strong>TreeSet</strong>.</td>
            </tr>
          </table>
        </section>

        <section>
          <pre>
            <code data-trim contenteditable>

TreeSet&lt;Integer&gt; tree=new TreeSet&lt;Integer&gt;();
    
System.out.println(tree.size());
/*Salida: 0*/
    
for(int i=0; i&lt;10; i++){
  tree.add(i);
}
    
System.out.println(tree.contains(15));
/*Salida: false*/

System.out.println(tree.pollFirst());
/*Salida: 0*/

System.out.println(tree.pollLast());
/*Salida: 9*/

System.out.println(tree.first());
/*Salida: ¿?*/

System.out.println(tree.last());
/*Salida: ¿?*/
            </code>
          </pre>
        </section>

        <section>
          <h3>TreeMap</h3>
          <p>Un Arbol Binario de Busqueda Balanceado es un manera de <strong>organizar</strong> datos. A diferencia del <i>TreeSet</i>, el <i>TreeMap</i> nos permite almacenar pares de <strong>Clave-Valor</strong>.</p>
        </section>

        <section>
          <img src="img/pair.jpg" alt="">
        </section>

        <section>
          <pre>
            <code data-trim contenteditable>
import java.util.TreeMap;

//Declaración de un TreeMap

TreeMap&lt;Integer, String&gt; tree=new TreeMap&lt;Integer, String&gt;();
TreeMap&lt;String, String&gt; nombres=new TreeMap&lt;String, String&gt;();
            </code>
          </pre>
        </section>

        <section>
          <h3>TreeMap: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>clear()</td>
              <td>Elimina todos los elementos del <strong>TreeMap</strong>.</td>
            </tr>
            <tr>
              <td>containsKey(key)</td>
              <td>Retorna un <i>boolean</i> que indica si existe un elemento con la clave <strong>key</strong> dentro del <strong>TreeMap</strong>.</td>
            </tr>
            <tr>
              <td>containsValue(value)</td>
              <td>Retorna un <i>boolean</i> que indica si existe una o mas claves con el valor <strong>value</strong> dentro del <strong>TreeMap</strong>.</td>
            </tr>
          </table>
        </section>

        <section>
          <h3>TreeMap: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>firstKey()</td>
              <td>Retorna la <i>clave</i> más pequeña del <strong>TreeMap</strong>.</td>
            </tr>
            <tr>
              <td>get(key)</td>
              <td>Retorna el <i>valor</i> asociado a la clave <strong>key</strong> del <strong>TreeMap</strong>.</td>
            </tr>
             <tr>
              <td>lastKey()</td>
              <td>Retorna la <i>clave</i> más grande del <strong>TreeMap</strong>.</td>
            </tr>
          </table>
        </section> 

        <section>
          <h3>TreeMap: Métodos</h3>
          <table>
            <tr>
              <th>Método</th>
              <th>Función</th>
            </tr>
            <tr>
              <td>put(key, value)</td>
              <td>Asocia el valor <strong>value</strong> a la clave <strong>key</strong> y los inserta al <strong>TreeMap</strong>.</td>
            </tr>
            <tr>
              <td>remove(key)</td>
              <td>Retorna el <i>valor</i> y elimina el par asociado a la clave <strong>key</strong> del <strong>TreeMap</strong>.</td>
            </tr>
            <tr>
              <td>size()</td>
              <td>Retorna el número de pares <i>clave/valor</i> que se encuentran en el <strong>TreeMap</strong>.</td>
            </tr>
          </table>
        </section>

        <section>
          <pre>
            <code data-trim contenteditable>

TreeMap&lt;Integer, String&gt; tree=new TreeMap&lt;Integer, String&gt;();

tree.put(1150990, "Angie Melissa");
tree.put(1150972, "Gerson Yesid");
tree.put(11509, "Cristhian Leonardo");
    
System.out.println(tree.size());
/*Salida: 3*/

System.out.println(tree.containsKey(1150972));
/*Salida: true*/

System.out.println(tree.containsValue("David"));
/*Salida: false*/

System.out.println(tree.firstKey());
/*Salida: 11509*/

System.out.println(tree.lastKey());
/*Salida: 1150990*/

System.out.println(tree.get(1150990));
/*Salida: ¿?*/
            </code>
          </pre>
        </section>     
       
        <section>
        	<h3>Ejercicios propuestos</h3>
        	<a href="https://github.com/ProgramacionCompetitivaUFPS/Syllabus/blob/master/Ejercicios%20Propuestos/Estructuras%20de%20datos.md">https://github.com/ProgramacionCompetitivaUFPS/Syllabus</a>
        </section>
			</div>

		</div>

		<script src="../assets/lib/js/head.min.js"></script>
		<script src="../assets/js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: '../assets/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../assets/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../assets/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../assets/plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../assets/plugin/zoom-js/zoom.js', async: true },
					{ src: '../assets/plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
