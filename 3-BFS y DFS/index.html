<!doctype html>
<html lang="es">

	<head>
		<meta charset="utf-8">
		<title>BFS y DFS</title>
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
		<link rel="stylesheet" href="../assets/css/reveal.css">
		<link rel="stylesheet" href="../assets/css/theme/ufps.css" id="theme">
		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="../assets/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../assets/css/print/pdf.css' : '../assets/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Búsqueda en anchura (BFS) y Búsqueda en profundidad (DFS)</h2>
        		</section>
        		<section>
        			<p>Búsqueda en anchura y búsqueda en profundidad son dos algoritmos para recorrer o buscar elementos en un grafo. </p>
        			<img src="img/grafo.png" alt="">
        		</section>
        		<section>
        			<h3>Búsqueda en Anchura</h3>
        			<p>Intuitivamente, se comienza en la raíz (eligiendo algún nodo como elemento raíz en el caso de un grafo) y se exploran todos los vecinos de este nodo. A continuación para cada uno de los vecinos se exploran sus respectivos vecinos adyacentes, y así hasta que se recorra todo el árbol.</p>
        		</section>
        		<section>
        			<img src="img/BFS.png" alt="">
        		</section>
        		<section>
        			<h3>Implementación de BFS</h3>
        			<pre>
        				<code>
metodo BFS(grafo, nodo_origen):
  creamos una cola Q
  agregamos el nodo_origen a la cola Q
  marcamos nodo_origen como visitado
  mientras Q no esté vacío:
    sacamos un elemento de la cola Q (lo llamamos v)
    para cada vertice w adyacente a v:
      si w no ha sido marcado como visitado
        marcamos w como visitado
        insertamos w en la cola Q

        				</code>
        			</pre>
        		</section>
        		<section>
        			<img src="img/grafo.JPG" alt="">
        		</section>
        		<section>
        			<img src="img/bfs.gif" alt="">
        		</section>
        		<section>
        			<h3>Ejemplo</h3>
        			<p>Tenemos una matriz de caracteres que representa un laberinto 2D un ‘#’ implica un muro, un ‘.’ implica un espacio libre, un ‘I’ indica la entrada del laberinto y una ‘S’ indica una salida. ¿Cuanto mide la ruta mas corta para escapar?</p>
        			<img src="img/laberinto.jpg" alt="">
        		</section>
        		<section>
        			<h3>Posibles estados adyacentes:</h3>
					<ul>
						<li>(x, y + 1)</li>
						<li>(x, y - 1)</li>
						<li>(x + 1, y)</li>
						<li>(x - 1, y)</li>
					</ul>

        		</section>
        		<section>
        			<h3>Estructuras a utilizar</h3>
        			<pre>
        				<code>
static char ady[] [] = new char[ 100 ] [ 100 ];
	
static class Estado{
  int x , y , d;	
  public Estado( int x1, int y1 , int d1){
    this.x = x1;
    this.y = y1;
    this.d = d1;
  }
};
        				</code>
        			</pre>
        		</section>
        		<section>
        			<h3>Método BFS</h3>
        			<pre>
        				<code>
public static int BFS( int x , int y , int h , int w ){ 

	boolean visitado[] [] = new boolean[ 100 ] [ 100 ];	
	Queue&lt;Estado&gt; Q = new LinkedList&lt;Estado&gt;();	
	Q.add( new Estado( x , y , 0 ) );   
	visitado[x][y] = true; 
		
	int dx[  ] = { 0 ,  0 , 1 , -1 };	
	int dy[  ] = { 1 , -1 , 0 ,  0 };	
	int nx , ny;
		
	while( !Q.isEmpty() ){	
		Estado actual = Q.remove();		
		if( ady[actual.x] [actual.y] == 'S' ){	
			return actual.d;	
		}
			
		for( int i = 0 ; i &lt; 4 ; ++i ){	
			nx = dx[ i ] + actual.x;	
			ny = dy[ i ] + actual.y;	
			if( nx &gt;= 0 && nx &lt; h && ny &gt;= 0 && ny &lt; w && !visitado[nx] [ny] && ady[nx] [ny] != '#' ){
				Q.add( new Estado( nx , ny , actual.d + 1 ) ); 
				visitado[nx][ny] = true;
			}
		}
	}
	return -1;
}
        				</code>
        			</pre>
        		</section>
        		<section>
        			<h3>Búsqueda en profundidad</h3>
        			<p>
        				Su funcionamiento consiste en ir expandiendo todos y cada uno de los nodos que va localizando, de forma recurrente, en un camino concreto. Cuando ya no quedan más nodos que visitar en dicho camino, regresa, de modo que repite el mismo proceso con cada uno de los hermanos del nodo ya procesado.

        			</p>
        		</section>
        		<section>
        			<img src="img/DFS.png" alt="">
        		</section>
        		<section>
        			<h3>Implementación de DFS</h3>
        			<pre>
        				<code>
        				
metodo DFS(nodo_origen):
  marcamos origen como visitado
  para cada vertice v adyacente a origen en el grafo:
    si v no ha sido visitado:
      marcamos como visitado v
      llamamos recursivamente DFS(v)

        				</code>
        			</pre>
        		</section>
        		<section>
        			<img src="img/grafo.JPG" alt="">
        		</section>
        		<section>
        			<img src="img/dfs.gif" alt="">
        		</section>
        		<section>
        			<h3>Ejemplo</h3>
        			<p>Tenemos una matriz de caracteres que representa un laberinto 2D un ‘#’ implica un muro, un ‘.’ implica un espacio libre, un ‘I’ indica la entrada del laberinto y una ‘S’ indica una salida. ¿Es posible llegar a una salida?</p>
        			<img src="img/laberinto.jpg" alt="">
        		</section>
        		<section>
        			<h3>Estructuras</h3>
        			<pre>
        				<code>
static char ady[] [] = new char[100] [100];	
static boolean visitado[] [] = new boolean[100] [100];
        				</code>
        			</pre>
        		</section>
        		<section>
        			<pre>
        				<code>
public static boolean DFS( int x , int y , int h , int w ){ 
		
	if(ady[x] [y]=='S'){
		return true;
	}
	visitado[x][y] = true;
		
	int dx[ ] = { 0 ,  0 , 1 , -1 };	
	int dy[ ] = { 1 , -1 , 0 ,  0 };		
	int nx , ny;
		
	for( int i = 0 ; i &lt; 4 ; ++i ){				
		nx = dx[ i ] + x;				
		ny = dy[ i ] + y;
		if( nx &gt;= 0 && nx &lt; h && ny &gt;= 0 && ny &lt; w && !visitado[ nx ][ ny ] && ady[ nx ][ ny ] != '#' ){
			visitado[nx] [ny] = true;
			if( DFS (nx, ny, h, w) ){
				return true;
			}
		}
	}
	return false;
}
        				</code>
        			</pre>
        		</section>
        		<section>
        			<h3>Comparación BFS vs. DFS</h3>
        			<img src="img/bfs.gif" alt="">
        			<img src="img/dfs.gif" alt="">
        		</section>
        		<section>
        			<h3>Fuentes e información adicional</h3>
        			<ul>
        				<li>
        					<a href="https://jariasf.wordpress.com/2012/02/27/algoritmo-de-busqueda-breadth-first-search/">https://jariasf.wordpress.com/2012/02/27/algoritmo-de-busqueda-breadth-first-search/</a>
        				</li>
        				<li>
		        			<a href="https://jariasf.wordpress.com/2012/03/02/algoritmo-de-busqueda-depth-first-search-parte-1/">https://jariasf.wordpress.com/2012/03/02/algoritmo-de-busqueda-depth-first-search-parte-1/</a>
        				</li>

        			</ul>
        		</section>
        		<section>
        			<h3>Ejercicios Propuestos</h3>
        			<a href="https://github.com/ProgramacionCompetitivaUFPS/Syllabus/blob/master/Ejercicios Propuestos/BFS y DFS.md">https://github.com/ProgramacionCompetitivaUFPS/Syllabus</a>
        		</section>
			</div>

		</div>

		<script src="../assets/lib/js/head.min.js"></script>
		<script src="../assets/js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: '../assets/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../assets/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../assets/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../assets/plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../assets/plugin/zoom-js/zoom.js', async: true },
					{ src: '../assets/plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
